#!/bin/bash
#
# Immersion Pod - Passive listening management tool
# Copyright (C) 2021 Ren Tatsumoto. <tatsu at autistici.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# Any modifications to this file must keep this entire header intact.

readonly program='immersionpod'
readonly current='current'
readonly archive='archive'
readonly config_filepath=${XDG_CONFIG_HOME:-$HOME/.config}/$program/config
readonly tmp_dir="/tmp/$program"
readonly chunks_dir="$tmp_dir/chunks"

load_default_config() {
	langs=jpn,eng,rus,ukr
	prefer_internal_subs=yes
	video_dir=~/Videos/ongoing
	bitrate=32k
	recent_threshold=10
}

ensure_dirs() {
	mkdir -p "$(dirname -- "${config_filepath:?}")"
	mkdir -p "$immersionpod_dir"/{$current,$archive}
	mkdir -p "$chunks_dir"
}

echo_help() {
	local -r bn=$(basename -- "$0")
	cat <<-EOF
		Usage: $bn ACTION [OPTION] FILE
		Manage immersion audio.

		ACTION Commands:
		  add [OPTION] FILE	Add files to Immersion pod.
		    add Options:
		      -f, --force	Overwrite existing files.
		      -n, --no-condense	Don't condense audio.

		  add_recent		Add new files from your video directory to Immersion pod.
		  archive		Move episodes older than $recent_threshold days to archive folder.
		  reshuffle		Re-add files to the playlist, shuffle them and start playing.
		  rotate		add_recent, archive, reshuffle

		Examples:
		  $bn add -f 'video.mkv'
		  $bn rotate
	EOF
}

probe_tracks() {
	local -r track_type=${1:?}
	local -r video_fp=${2:?}
	ffprobe \
		-loglevel error \
		-select_streams "$track_type" \
		-show_entries stream=index:stream_tags=language,title \
		-print_format csv=print_section=0 \
		"$video_fp"
}

best_track() {
	local -r track_type=${1:?}
	local -r video=${2:?}
	local -r tracks=$(probe_tracks "$track_type" "$video")

	while IFS= read -r lang; do
		while IFS= read -r track; do
			track_num=$(cut -d, -f1 <<<"$track")
			track_lang=$(cut -d, -f2 <<<"$track")
			if [[ $lang == "$track_lang" ]]; then
				echo "$track_num"
				return
			fi
		done <<<"$tracks"
	done <<<"${langs//,/$'\n'}"
	unset lang track
}

find_recent_videos() {
	# Search files that have been modified in the last N days
	find "$video_dir" \
		-type f \( -name '*.mkv' -o -name '*.mp4' \) \
		-mtime "-$recent_threshold" -print0 || exit 2
}

find_outdated_audio() {
	find "$immersionpod_dir/$current" -maxdepth 1 -type f -mtime "+$recent_threshold" -print0 || exit 2
}

fetch_video_title() {
	local -r input=${1:?Path to video file is not set.}
	strip() {
		sed -e 's/_/ /g' \
		-e 's/fansub\|vostfr\|10bits\|BluRay\|x26[45]\|AAC\|flac//gi' \
		-Ee 's/[0-9]{3,4}[pP]//g' \
		-Ee 's/(\[|\()[^])]*(\]|\))//g' \
		-e 's/^ *//; s/ *$//' \
		-Ee 's/ +/ /g'
	}
	print_name() {
		basename -- "${input%.*}"
	}
	print_name | strip
}

extract_subtitles() {
	local -r input=${1:?}
	local -r output=${2:?}
	local -r track_num=$(best_track s "$input")

	echo "Extracting subtitles #$track_num from of $(basename -- "$input")..."
	ffmpeg -nostdin \
		-loglevel error \
		-hide_banner \
		-n \
		-i "$input" \
		-map_metadata -1 \
		-vn \
		-an \
		-map "0:${track_num:-s}" \
		-f "${output##*.}" \
		"$output" &&
		echo "$output has been written."
}

extract_audio() {
	local -r input=${1:?}
	local -r output=${2:-$immersionpod_dir/$current/$(basename -- "${input%.*}").ogg}
	local -r title=$(fetch_video_title "$input")
	local -r track_num=$(best_track a "$input")

	if [[ ! -r "$input" ]]; then
		echo "Error: Can't read file $input." >&2
		return 1
	fi

	if [[ ! -w "$(dirname -- "$output")" ]]; then
		echo "Error: Can't write file $output." >&2
		return 1
	fi

	if [[ -f "$output" ]] && [[ -z $global_overwrite ]]; then
		echo "Warning: $(basename -- "$output") already exists. Doing nothing." >&2
		return 1
	fi

	echo "Extracting audio #$track_num from of $(basename -- "$input")..."
	ffmpeg -nostdin \
		-loglevel error \
		-hide_banner \
		"-${global_overwrite:-n}" \
		-i "$input" \
		-map_metadata -1 \
		-vn \
		-map "0:${track_num:-a}" \
		-ac 2 \
		-ab "$bitrate" \
		-vbr on \
		-compression_level 10 \
		-application voip \
		-acodec libopus \
		-metadata title="$title" \
		"$output" &&
		echo "$output has been written."
}

make_chunk() {
	local -r input=${1:?}
	local -r output=${2:?}
	local -r start=${3:?}
	local -r end=${4:?}

	echo "$start,$end"

	ffmpeg -nostdin \
		-loglevel error \
		-hide_banner \
		-n \
		-vn \
		-i "$input" \
		-map_metadata -1 \
		-codec:a copy \
		-ss "$start" \
		-to "$end" \
		"$output"
}

find_external_subtitles() {
	local -r video=${1:?}
	local -r dir=$(dirname -- "$video")
	local -r base=$(basename -- "${video%.*}")
	find "$dir" \( -name "$base*.srt" -o -name "$base*.ass" \) | head -1
}

to_srt() {
	local -r input=${1:?}
	local -r output=${2:?}

	ffmpeg -nostdin \
		-loglevel error \
		-hide_banner \
		-y \
		-vn \
		-an \
		-i "$input" \
		-f srt \
		"$output"
}

make_condensed() {
	local -r video=${1:?}
	local -r base=$(basename -- "${video%.*}")
	local -r audio=$tmp_dir/$base.ogg
	local -r condenced_audio=${2:-$immersionpod_dir/$current/$base.ogg}
	local -r chunks_file=$tmp_dir/$base.list
	local -r subtitles=$tmp_dir/$base.srt
	local -r ext_subtitles=$(find_external_subtitles "$video")

	if [[ -f $condenced_audio ]] && [[ -z $global_overwrite ]]; then
		echo "Warning: $(basename -- "$condenced_audio") already exists. Doing nothing." >&2
		return 2
	fi

	if [[ ! -f $audio ]]; then
		extract_audio "$video" "$audio" || return 1
	fi

	if [[ $prefer_internal_subs == 'yes' ]]; then
		if [[ -f "$subtitles" ]] || extract_subtitles "$video" "$subtitles"; then
			echo "Extracted internal subtitles."
		else
			echo -n "Failed to extract internal subtitles. "
			if [[ -f $ext_subtitles ]]; then
				echo "External subtitle file '$(basename -- "$ext_subtitles")' will be used."
				to_srt "$ext_subtitles" "$subtitles"
			else
				echo "File will be added without condensing."
				mv "$audio" "$condenced_audio"
				return
			fi
		fi
	else
		if [[ -f $ext_subtitles ]]; then
			echo "External subtitle file '$(basename -- "$ext_subtitles")' will be used."
			to_srt "$ext_subtitles" "$subtitles"
		else
			if [[ -f "$subtitles" ]] || extract_subtitles "$video" "$subtitles"; then
				echo "Extracted internal subtitles."
			else
				echo "Failed to extract internal subtitles. File will be added without condensing."
				mv "$audio" "$condenced_audio"
				return
			fi
		fi
	fi

	local timings start end
	while read -r timings; do
		timings=${timings//,/.}
		start=${timings% --> *}
		end=${timings#* --> }
		make_chunk "$audio" "$chunks_dir/${base}_${start}.ogg" "$start" "$end"
	done < <(grep ' --> ' "${subtitles:?}")

	find "$chunks_dir" -type f | tac | sed "s/^/file '/g; s/$/'/g" >"$chunks_file"

	ffmpeg -nostdin \
		-hide_banner \
		-loglevel error \
		-vn \
		"-${global_overwrite:-n}" \
		-f concat \
		-safe 0 \
		-i "$chunks_file" \
		-c copy \
		-metadata title="$(fetch_video_title "${video:?}")" \
		"$condenced_audio"
	local -r ret=$?

	# cleanup
	rm -rf -- "${chunks_dir:?}"/*

	return $ret
}

notify_send() {
	local -r msg=${*:?}
	command -v notify-send >/dev/null && notify-send "Immersion pod" "$msg"
	echo "$msg"
}

add_notify() {
	local -r video=${1:?}
	local -r msg="$(basename -- "$video") has been added."
	local -r func=$([[ -z $global_no_condense ]] && echo 'make_condensed' || echo 'extract_audio')

	case $video in
		http*youtube.com* | http*youtu.be*) add_yt "$video" && notify_send "$msg" ;;
		*) "$func" "$video" && notify_send "$msg" ;;
	esac
}

add() {
	local videos=()
	for arg; do
		case $arg in
			-n | --no-condense) readonly global_no_condense='y' ;;
			-f | --force) readonly global_overwrite='y' ;;
			*) if [[ -f $arg ]] || [[ $arg == http*youtu*be* ]]; then
				videos+=("$arg")
			else
				echo "Error: '$arg' doesn't exist." >&2
				return 1
			fi ;;
		esac
	done
	unset arg
	for video in "${videos[@]}"; do
		add_notify "$video"
	done
}

add_stdin() {
	while IFS= read -r -d $'\0' video; do
		add_notify "$video"
	done
}

add_recent() {
	find_recent_videos | add_stdin
}

add_yt() {
	if command -v youtube-dl >/dev/null; then
		youtube-dl \
			--ignore-errors \
			--extract-audio \
			--add-metadata \
			--continue \
			-f bestaudio/best \
			-o "$immersionpod_dir/$current/%(uploader)s%(title)s.%(ext)s" \
			"${*:?}"
	else
		echo "Error: 'youtube-dl' is not installed." >&2
	fi
}

archive() {
	local -r archive_fol="$immersionpod_dir/$archive/$(date '+%Y-%V')"

	echo "Archiving old episodes..."

	old_episodes=()
	while IFS= read -r -d $'\0' filename; do
		old_episodes+=("$filename")
	done < <(find_outdated_audio)

	# if there are old episodes, crate a dir for them and then move them
	if [[ ${#old_episodes[@]} -gt 0 ]]; then
		mkdir -pv "$archive_fol"
		mv -v "${old_episodes[@]}" "$archive_fol"
		local -r msg="Archived ${#old_episodes[@]} episodes."
	else
		local -r msg="Nothing to archive."
	fi

	notify_send "$msg"
}

rotate() {
	add_recent
	archive
	reshuffle
}

reshuffle() {
	command -v mpc >/dev/null || echo "Error: mpc is not installed." >&2 && return 1
	mpc update "$program/$current"
	mpc crop
	mpc add "$program/$current"
	mpc shuffle
	mpc play
}

get_mpd_folder() {
	# https://wiki.archlinux.org/index.php/Music_Player_Daemon#Configuration
	local -r path=~/.config/mpd/mpd.conf
	{
		sed -n '/^music_directory/ {s/^music_directory[^"]*"\(.*\)"$/\1/p; q}' "$path"
		# shellcheck disable=SC2088
		echo '~/music'
	} | head -1
} && {
	_dir="$(get_mpd_folder)/$program"
	_dir=${_dir//\/\//\/}
	_dir=${_dir/\~/$HOME}
	readonly immersionpod_dir=$_dir
	unset _dir
}

version() {
	cat <<-EOF
	$(basename -- "$0") v0.1
	Copyright (C) $(date +%Y) Ren Tatsumoto.
	License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.
	EOF
}

main() {
	# Load default configuration, then override settings with the config file
	load_default_config
	ensure_dirs

	# shellcheck source=/dev/null
	if [[ -f ${config_filepath:?} ]]; then
		source "$config_filepath"
	fi

	if [[ -z $1 ]] || [[ $1 == --help ]] || [[ $1 == -h ]]; then
		echo_help
	elif [[ $1 == --version ]] || [[ $1 == -v ]]; then
		version
	elif declare -f "$1" >/dev/null && [[ $1 != "${FUNCNAME[0]}" ]]; then
		# call arguments verbatim
		"$@"
		local -r ret=$?
		rm -rf -- "${tmp_dir:?}"/*
	else
		echo "Error: '$1' is not a known function name." >&2
		echo_help
		local -r ret=1
	fi

	return $ret
}

#
# MAIN
# Do not change anything here. If you want to modify the code, edit main()
#
main "$@"
